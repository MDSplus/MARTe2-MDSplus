function pp = RABBIT_loadparams(machine,varargin)

[machine,test,nsource] = parse_inputs(machine,varargin{:});

pp = Simulink.Parameter;
if test
  %%% TEST CASES
  switch machine
    case 'TCV'
      pp.Value = default_RABBIT_params_TCV_test(nsource);
    case 'JET'
      pp.Value = default_RABBIT_params_JET_test(nsource);
    otherwise
      error('no test defined for this machine');
  end
else
  %%% TRUE DATA
  switch machine
    case 'TCV'
      pp.Value = default_RABBIT_params_TCV_real(nsource);
    otherwise
      error('not done yet');
  end
  
end
end

function params = default_RABBIT_params_TCV_real(nsource)

set_RABBIT_namelist('namelist_tcv.nml');
% Real data for TCV
[xstart,xvec,beamwidthpoly] = get_beamgeom_TCV(nsource);

params = struct(...
  'aplasma',2,...
  'zplasma',1,...
  'aimp',12,...
  'zimp',6,...
  'abeam',repmat(2.0,nsource,1),...
  'zbeam',repmat(1.0,nsource,1),...
  'xstart',xstart,...
  'xvec',xvec,...
  'beamwidthpoly',beamwidthpoly,...
  'nv',3,...
  'nsource',(nsource),...
  'nrhotor_out',21,...
  'R',linspace(0.5,1.3,28)',...
  'Z',linspace(-1.1,1.1,65)',...
  'l',(17),...
  'p',(11));
end

function params = default_RABBIT_params_TCV_test(nsource)


if nsource==1
  set_RABBIT_namelist('namelist_tcv.nml');
  
  params = struct(...
    'aplasma',2,...
    'zplasma',1,...
    'aimp',12,...
    'zimp',6,...
    'abeam',2,...
    'zbeam',1,...
    'xstart',[2 0 0]',...
    'xvec',[-1 0 0]',...
    'beamwidthpoly',[.05     0       0]',...
    'nv',(3),...
    'nsource',(1),...
    'nrhotor_out',(21),...
    'R',linspace(0.5,1.3,28)',...
    'Z',linspace(-1.1,1.1,65)',...
    'l',(17),...
    'p',(11));
elseif nsource>1
  params = default_RABBIT_params_TCV_test(1); % get 1 beam default
  params.nsource = nsource;
  params.beamwidthpoly = repmat(params.beamwidthpoly ,1,nsource);
  params.abeam = repmat(params.abeam,nsource,1);
  params.zbeam = repmat(params.zbeam,nsource,1);
  params.xstart = bsxfun(@plus,[2;0;0],linspace(1,1.1,nsource)); % displace each beam upwards
  params.xvec = repmat([-1;0;0],1,nsource);
else
  error('invalid nsource')
end
end


function params = default_RABBIT_params_JET_test(nsource)

if nsource==1
  set_RABBIT_namelist('namelist_jet.nml');
  
  params = struct(...
    'aplasma',2,...
    'zplasma',1,...
    'aimp',12,...
    'zimp',6,...
    'abeam',2,...
    'zbeam',1,...
    'xstart',[5 0 0]',...
    'xvec',[-1 0 0]',...
    'beamwidthpoly',[.05     0       0]',...
    'nv',(3),...
    'nsource',(1),...
    'nrhotor_out',(21),...
    'R',linspace(1.5,4,26)',...
    'Z',linspace(-2.5,2.5,51)',...
    'l',(17),...
    'p',(11));
else
  error('invalid nsource')
end
end



function [xstart,xvec,beamwidthpoly] = get_beamgeom_TCV(nsource)


%% information for first NBI
xstart = [-3.8935455      -2.4286423       0.0000000]';
xvec = [0.75259123      0.65848799       0.0000000]';
beamwidthpoly = [0.75259123      0.65848799       0.0000000]';

if nsource==2
  % second NBI
  th = 135 * (pi/180); % beams mirrored w.r.t. vertical plane making 130 angle with x axis
  reflmat = [ cos(2*th), sin(2*th), 0; sin(2*th), -cos(2*th), 0; 0, 0, 1 ]; % reflection matrix
  
  xstart = [xstart,reflmat*xstart];
  xvec = [xvec,reflmat*xvec];
  beamwidthpoly = [beamwidthpoly,beamwidthpoly];
elseif nsource>2
  error('nsource can be at most 2 for TCV')
end
end


function [machine,test,nsource] = parse_inputs(machine,varargin)
p = inputParser;
defaultMachine = 'TCV';
defaultTest = false;
defaultnsource = 1;
addOptional(p,'machine',defaultMachine,@ischar)
addParameter(p,'test',defaultTest,@islogical)
addParameter(p,'nsource',defaultnsource,@(n) (n>0 && int8(n)==n));

parse(p,machine,varargin{:});
machine = p.Results.machine;
test    = p.Results.test;
nsource = p.Results.nsource;
end
